from __future__ import division
import numpy as np
import os

N_NODES = 10
N_QUEUE = 5
 
def computeStates():
    # Generates the Markov Chain depicted in the report
    states = [] # [n nodes trasmitting:int, m nodes holding:int, no collision:bool]

    for i in range(0, N_NODES+1):
        if i == 0:
            # first line of MC transition states
            states.append([0, 0, True, False])
        else:
            status = True if i == 1 else False
            # all states where one node is transmitting, either colliding or successfully
            for j in range(0, N_NODES*N_QUEUE+2):
                loosing = False
                if(j == N_NODES*N_QUEUE+1):
                    j = N_NODES*N_QUEUE
                    loosing = True
                states.append([i, j, status, loosing])
    #print(states)
    return states

def find_state(state, states):
    # Return the position of a state
    waiting = state[1]
    if(not state[3]):
        if(waiting == N_NODES*N_QUEUE+1):
            state[1] = N_NODES*N_QUEUE
            state[3] = True
    else:
        state[3] = False
    if state in states:
        return states.index(state)
    else:
        return -1

def computeSend(item, rate):
    """
    Compute the transition rate
    when a new packet is generated by an idle node
    """
    return rate * N_NODES

def computeEndTransmission(item, rate):
    # No. of transmitting nodes multiplied by mu
    # 6.026 byte with speed 1MB/s
    return 166.667
    
    #if((item[1] * size) < rate):

    size = 166.67
    if(item[1] == 0):
        return size

    t2 = ( rate * N_NODES ) / item[1]
    t1 = size
    #print(t2, " ", t1)

    com = t2*t1
    d = ( t2 - t1 ) / com
    if(d > 0):
        return 1/d
    return rate * N_NODES

def computeMatrix(states, rate):
    """
    Compute the infinitesimal generator
    """
    matrix = np.zeros((len(states), len(states)))

    for index, item in enumerate(states):
        if item == [0, 0, True, False]:
            # first state
            matrix[0][1] = computeSend([0, 0], rate)
        else:
            # other states

            # START OF TRANSMISSION
            next_state = [item[0], item[1] + 1, item[2], item[3]]
            position = find_state(next_state, states)
            if position != -1:
                matrix[index][position] = computeSend(item, rate)

            # END OF TRANSMISSION
            status = True if item[1] <= 1 else False
            if(item[1] <= N_NODES):
                next_state = [item[1], 0, status, item[3]]
            else:
                status = True if N_NODES == 1 else False
                next_state = [N_NODES, item[1]-N_NODES, status, item[3]]
            position = find_state(next_state, states)
            if position != -1:
                matrix[index][position] = computeEndTransmission(item, rate)
                #print(matrix[index][position])

    # the diagonal
    for x in range(0, len(matrix)):
        matrix[x][x] = -sum(matrix[x])
    #print(matrix)
    return matrix

def append_results(l, steady_state):
    """
    Save the steady state distribution to a csv file
    """
    output = './model/data/output.csv'
    os.makedirs(os.path.dirname(output), exist_ok=True)
    with open(output, 'a') as f:
        for index, p in enumerate(steady_state):
            if(index != 0):
                state = states[index]
                status = 't' if state[2] else 'c'
                loosing = 1 if state[3] else 0
                if p < 0:
                    p = 0
                transmitting = state[0]
                holding = state[1]
                f.write('{},{},{},{},{},{}\n'.format(transmitting, holding, status, p, loosing, l)) 

def replace_last_column_with_1(matrix):
    matrix[::,-1] = 1
    return matrix

if __name__ == "__main__":

    output = './model/data/output.csv'
    f = open(output, 'w+')
    f.write('transmitting,holding,state,prob,loosing,rate\n')
    f.close()

    states = computeStates()
    N = len(states)

    rates = [333.33, 250, 200, 175, 150, 125, 100, 75, 50, 45, 40, 38, 35, 32.5, 30, 27.5, 25, 23.5, 22, 19, 17, 15, 13, 12, 11, 10, 9, 8, 7, 6, 5, 2, 1, 0.5, 0.01]
    #rates = [166.66]
    for rate in rates:
        
        transition_matrix = computeMatrix(states, rate)
        Q = np.ones((N, N + 1))
        Q[:,:-1] = transition_matrix

        b = [0] * N
        b.append(1)
        # compute the steady state
        # use lstsq numpy function to solve ax=b, where a is Q transposed, b is a probability vector like [0,0,...,0,1], x is the returned solution
        # solving the equation 4 in the report
        # https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.linalg.lstsq.html
        steady_state_matrix = np.linalg.lstsq(Q.transpose(), b)
        append_results(rate, steady_state_matrix[0])
        print("> ", rate, " done")

print('Finish. Use \'makefile analysis\' to analyze the model')